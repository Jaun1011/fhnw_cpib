
(*
generated by jku, ica
*)
datatype nonterm
    = program
    | progParamList
    | cpsCmd
    | cpsDecl
    | decl
    | stoDecl
    | funDecl
    | procDecl
    | typedIdent
    | paramList
    | globImps
    | cpsStoDecl
    | globImp
    | globImpsOpt
    | cpsDeclOpt
    | cpsStoDeclOpt
    | progParam
    | progParamListOpt
    | param
    | paramListOpt
    | cmd
    | expr
    | exprList
    | cpsCmdOpt
    | globInits
    | idents
    | identsOpt
    | term1
    | exprOpt
    | term2
    | term3
    | term2Opt
    | factor
    | term3Opt
    | monadicOpr
    | exprListOpt

val string_of_nonterm =
    fn program => "program"
    | progParamList => "progParamList"
    | cpsCmd => "cpsCmd"
    | cpsDecl => "cpsDecl"
    | decl => "decl"
    | stoDecl => "stoDecl"
    | funDecl => "funDecl"
    | procDecl => "procDecl"
    | typedIdent => "typedIdent"
    | paramList => "paramList"
    | globImps => "globImps"
    | cpsStoDecl => "cpsStoDecl"
    | globImp => "globImp"
    | globImpsOpt => "globImpsOpt"
    | cpsDeclOpt => "cpsDeclOpt"
    | cpsStoDeclOpt => "cpsStoDeclOpt"
    | progParam => "progParam"
    | progParamListOpt => "progParamListOpt"
    | param => "param"
    | paramListOpt => "paramListOpt"
    | cmd => "cmd"
    | expr => "expr"
    | exprList => "exprList"
    | cpsCmdOpt => "cpsCmdOpt"
    | globInits => "globInits"
    | idents => "idents"
    | identsOpt => "identsOpt"
    | term1 => "term1"
    | exprOpt => "exprOpt"
    | term2 => "term2"
    | term3 => "term3"
    | term2Opt => "term2Opt"
    | factor => "factor"
    | term3Opt => "term3Opt"
    | monadicOpr => "monadicOpr"
    | exprListOpt => "exprListOpt"

datatype term
    = PROGRAM
    | IDENT
    | DO
    | ENDPROGRAM
    | GLOBAL
    | CHANGEMODE
    | FUN
    | RETURNS
    | LOCAL
    | ENDFUN
    | PROC
    | ENDPROC
    | COMMA
    | FLOWMODE
    | SEMICOLON
    | LPAREN
    | RPAREN
    | MECHMODE
    | COLON
    | ATOMTYPE
    | SKIP
    | BECOMES
    | IF
    | THEN
    | ELSE
    | ENDIF
    | WHILE
    | ENDWHILE
    | CALL
    | GLOBINITS
    | DEBUGIN
    | DEBUGOUT
    | INIT
    | BOOLOPR
    | RELOPR
    | ADDOPR
    | MULTOPR
    | LITERAL
    | NOT

val string_of_term =
    fn PROGRAM => "PROGRAM"
    | IDENT => "IDENT"
    | DO => "DO"
    | ENDPROGRAM => "ENDPROGRAM"
    | GLOBAL => "GLOBAL"
    | CHANGEMODE => "CHANGEMODE"
    | FUN => "FUN"
    | RETURNS => "RETURNS"
    | LOCAL => "LOCAL"
    | ENDFUN => "ENDFUN"
    | PROC => "PROC"
    | ENDPROC => "ENDPROC"
    | COMMA => "COMMA"
    | FLOWMODE => "FLOWMODE"
    | SEMICOLON => "SEMICOLON"
    | LPAREN => "LPAREN"
    | RPAREN => "RPAREN"
    | MECHMODE => "MECHMODE"
    | COLON => "COLON"
    | ATOMTYPE => "ATOMTYPE"
    | SKIP => "SKIP"
    | BECOMES => "BECOMES"
    | IF => "IF"
    | THEN => "THEN"
    | ELSE => "ELSE"
    | ENDIF => "ENDIF"
    | WHILE => "WHILE"
    | ENDWHILE => "ENDWHILE"
    | CALL => "CALL"
    | GLOBINITS => "GLOBINITS"
    | DEBUGIN => "DEBUGIN"
    | DEBUGOUT => "DEBUGOUT"
    | INIT => "INIT"
    | BOOLOPR => "BOOLOPR"
    | RELOPR => "RELOPR"
    | ADDOPR => "ADDOPR"
    | MULTOPR => "MULTOPR"
    | LITERAL => "LITERAL"
    | NOT => "NOT"

val string_of_gramsym = (string_of_term, string_of_nonterm)
local
  open FixFoxi.FixFoxiCore
in
val productions = [
    (program, [
         [T PROGRAM, T IDENT, N progParamList, T DO, N cpsCmd, T ENDPROGRAM]
        ,[T PROGRAM, T IDENT, N progParamList, T GLOBAL, N cpsDecl, T DO, N cpsCmd, T ENDPROGRAM]]),
    (decl, [
         [N stoDecl]
        ,[N funDecl]
        ,[N procDecl]]),
    (stoDecl, [
         [T CHANGEMODE, N typedIdent]
        ,[N typedIdent]]),
    (funDecl, [
         [T FUN, T IDENT, N paramList, T RETURNS, N stoDecl, T GLOBAL, N globImps, T LOCAL, N cpsStoDecl, T DO, N cpsCmd, T ENDFUN]
        ,[T FUN, T IDENT, N paramList, T RETURNS, N stoDecl, T LOCAL, N cpsStoDecl, T DO, N cpsCmd, T ENDFUN]
        ,[T FUN, T IDENT, N paramList, T RETURNS, N stoDecl, T GLOBAL, N globImps, T DO, N cpsCmd, T ENDFUN]
        ,[T FUN, T IDENT, N paramList, T RETURNS, N stoDecl, T DO, N cpsCmd, T ENDFUN]]),
    (procDecl, [
         [T PROC, T IDENT, N paramList, T GLOBAL, N globImps, T LOCAL, N cpsStoDecl, T DO, N cpsCmd, T ENDPROC]
        ,[T PROC, T IDENT, N paramList, T LOCAL, N cpsStoDecl, T DO, N cpsCmd, T ENDPROC]
        ,[T PROC, T IDENT, N paramList, T GLOBAL, N globImps, T DO, N cpsCmd, T ENDPROC]
        ,[T PROC, T IDENT, N paramList, T DO, N cpsCmd, T ENDPROC]]),
    (globImps, [
         [N globImp]
        ,[N globImp, N globImpsOpt]]),
    (globImpsOpt, [
         [T COMMA, N globImp]
        ,[N globImpsOpt]]),
    (globImp, [
         [T FLOWMODE, T CHANGEMODE, T IDENT]
        ,[T CHANGEMODE, T IDENT]
        ,[T FLOWMODE, T IDENT]
        ,[T IDENT]]),
    (cpsDecl, [
         [N decl, N cpsDeclOpt]
        ,[N decl]]),
    (cpsDeclOpt, [
         [T SEMICOLON, N decl]
        ,[N cpsDeclOpt]]),
    (cpsStoDecl, [
         [N stoDecl]
        ,[N stoDecl, N cpsStoDeclOpt]]),
    (cpsStoDeclOpt, [
         [T SEMICOLON, N stoDecl]
        ,[N cpsStoDeclOpt]]),
    (progParamList, [
         [T LPAREN, N progParam, N progParamListOpt, T RPAREN]
        ,[T LPAREN, N progParam, T RPAREN]
        ,[T LPAREN, T RPAREN]]),
    (progParamListOpt, [
         [T COMMA, N progParam]
        ,[N progParamListOpt]]),
    (progParam, [
         [T FLOWMODE, T CHANGEMODE, N typedIdent]
        ,[T FLOWMODE, N typedIdent]
        ,[T CHANGEMODE, N typedIdent]
        ,[N typedIdent]]),
    (paramList, [
         [T LPAREN, T RPAREN]
        ,[T LPAREN, N param, N paramListOpt, T RPAREN]
        ,[T LPAREN, N param, T RPAREN]]),
    (paramListOpt, [
         [T COMMA, N param]
        ,[N paramListOpt]]),
    (param, [
         [T FLOWMODE, T MECHMODE, T CHANGEMODE, N typedIdent]
        ,[T FLOWMODE, N typedIdent]
        ,[T FLOWMODE, T MECHMODE, N typedIdent]
        ,[T FLOWMODE, T CHANGEMODE, N typedIdent]
        ,[T MECHMODE, N typedIdent]
        ,[T MECHMODE, T CHANGEMODE, N typedIdent]
        ,[T CHANGEMODE, N typedIdent]]),
    (typedIdent, [
         [T IDENT, T COLON, T ATOMTYPE]]),
    (cmd, [
         [T SKIP]
        ,[N expr, T BECOMES, N expr]
        ,[T IF, N expr, T THEN, N cpsCmd, T ELSE, N cpsCmd, T ENDIF]
        ,[T WHILE, N expr, T DO, N cpsCmd, T ENDWHILE]
        ,[T CALL, T IDENT, N exprList]
        ,[T CALL, T IDENT, N exprList, T GLOBINITS]
        ,[T DEBUGIN, N expr]
        ,[T DEBUGOUT, N expr]]),
    (cpsCmd, [
         [N cmd]
        ,[N cmd, N cpsCmdOpt]]),
    (cpsCmdOpt, [
         [T SEMICOLON, N cmd]]),
    (globInits, [
         [T INIT, N idents]]),
    (idents, [
         [T IDENT]
        ,[T IDENT, N identsOpt]]),
    (identsOpt, [
         [T COMMA, T IDENT]]),
    (expr, [
         [N term1]
        ,[N term1, N exprOpt]]),
    (exprOpt, [
         [T BOOLOPR, N term1]
        ,[N exprOpt]]),
    (term1, [
         [N term2]
        ,[N term2, T RELOPR, N term2]]),
    (term2, [
         [N term3]
        ,[N term3, N term2Opt]]),
    (term2Opt, [
         [T ADDOPR, N term3]
        ,[N term2Opt]]),
    (term3, [
         [N factor]
        ,[N factor, N term3Opt]]),
    (term3Opt, [
         [T MULTOPR, N factor]
        ,[N term3Opt]]),
    (factor, [
         [T LITERAL]
        ,[T IDENT]
        ,[T IDENT, T INIT]
        ,[T IDENT, N exprList]
        ,[N monadicOpr, N factor]
        ,[T LPAREN, N expr, T RPAREN]]),
    (exprList, [
         [T LPAREN, T RPAREN]
        ,[T LPAREN, N expr, N exprListOpt, T RPAREN]
        ,[T LPAREN, N expr, T RPAREN]]),
    (exprListOpt, [
         [T COMMA, N expr]
        ,[N exprListOpt]]),
    (monadicOpr, [
         [T NOT]
        ,[T ADDOPR]])
]

val S = expr
val result = fix_foxi productions S string_of_gramsym
end (* local *)
